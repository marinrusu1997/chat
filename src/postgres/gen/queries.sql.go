// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package gen

import (
	"context"
	"database/sql"

	"github.com/jackc/pgx/v5/pgtype"
)

const addChatParticipant = `-- name: AddChatParticipant :one

INSERT INTO chat_participant (
    chat_id,
    user_id,
    chat_type,
    role,
    permissions_bitmask
) VALUES (
             $1, $2, $3, $4, $5
         )
RETURNING chat_id, user_id, chat_type, role, permissions_bitmask, joined_at, rejoined_at, left_at, ban_reason, ban_type, banned_by, banned_until, ban_reason_note, invited_by, invited_at, last_read_message_id, last_read_at, muted_until, notification_level, custom_nickname, color_theme, settings, is_pinned, last_pinned_message_id
`

type AddChatParticipantParams struct {
	ChatID             int32                   `json:"chat_id"`
	UserID             int32                   `json:"user_id"`
	ChatType           ChatTypeEnum            `json:"chat_type"`
	Role               ChatParticipantRoleEnum `json:"role"`
	PermissionsBitmask pgtype.Bits             `json:"permissions_bitmask"`
}

// --
// Chat Participant Management
// --
func (q *Queries) AddChatParticipant(ctx context.Context, arg AddChatParticipantParams) (ChatParticipant, error) {
	row := q.db.QueryRow(ctx, addChatParticipant,
		arg.ChatID,
		arg.UserID,
		arg.ChatType,
		arg.Role,
		arg.PermissionsBitmask,
	)
	var i ChatParticipant
	err := row.Scan(
		&i.ChatID,
		&i.UserID,
		&i.ChatType,
		&i.Role,
		&i.PermissionsBitmask,
		&i.JoinedAt,
		&i.RejoinedAt,
		&i.LeftAt,
		&i.BanReason,
		&i.BanType,
		&i.BannedBy,
		&i.BannedUntil,
		&i.BanReasonNote,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.LastReadMessageID,
		&i.LastReadAt,
		&i.MutedUntil,
		&i.NotificationLevel,
		&i.CustomNickname,
		&i.ColorTheme,
		&i.Settings,
		&i.IsPinned,
		&i.LastPinnedMessageID,
	)
	return i, err
}

type AddOneTimePreKeysParams struct {
	DeviceID  int64  `json:"device_id"`
	PublicKey []byte `json:"public_key"`
}

const createChat = `-- name: CreateChat :one

INSERT INTO chat (
    type,
    visibility,
    post_policy,
    created_by,
    name,
    tags,
    topic,
    description
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8
         )
RETURNING id, type, visibility, post_policy, status, moderation_policy, encryption, name, name_fts, tags, topic, description, settings, created_by, created_at, parent_id, expires_at, threads_enabled
`

type CreateChatParams struct {
	Type        ChatTypeEnum       `json:"type"`
	Visibility  ChatVisibilityEnum `json:"visibility"`
	PostPolicy  ChatPostPolicyEnum `json:"post_policy"`
	CreatedBy   int32              `json:"created_by"`
	Name        pgtype.Text        `json:"name"`
	Tags        []string           `json:"tags"`
	Topic       pgtype.Text        `json:"topic"`
	Description pgtype.Text        `json:"description"`
}

// --
// Chat Management
// --
func (q *Queries) CreateChat(ctx context.Context, arg CreateChatParams) (Chat, error) {
	row := q.db.QueryRow(ctx, createChat,
		arg.Type,
		arg.Visibility,
		arg.PostPolicy,
		arg.CreatedBy,
		arg.Name,
		arg.Tags,
		arg.Topic,
		arg.Description,
	)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Visibility,
		&i.PostPolicy,
		&i.Status,
		&i.ModerationPolicy,
		&i.Encryption,
		&i.Name,
		&i.NameFts,
		&i.Tags,
		&i.Topic,
		&i.Description,
		&i.Settings,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ParentID,
		&i.ExpiresAt,
		&i.ThreadsEnabled,
	)
	return i, err
}

const createDevice = `-- name: CreateDevice :one

INSERT INTO chatting_device (
    user_id,
    name,
    role,
    fingerprint,
    last_seen_at
    -- expires_at is set by a trigger
) VALUES (
             $1, $2, $3, $4, NOW()
         )
RETURNING id, user_id, name, role, fingerprint, created_at, last_seen_at, expires_at
`

type CreateDeviceParams struct {
	UserID      int32                  `json:"user_id"`
	Name        string                 `json:"name"`
	Role        ChattingDeviceRoleEnum `json:"role"`
	Fingerprint []byte                 `json:"fingerprint"`
}

// --
// Device & Signal Key Management
// --
func (q *Queries) CreateDevice(ctx context.Context, arg CreateDeviceParams) (ChattingDevice, error) {
	row := q.db.QueryRow(ctx, createDevice,
		arg.UserID,
		arg.Name,
		arg.Role,
		arg.Fingerprint,
	)
	var i ChattingDevice
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Role,
		&i.Fingerprint,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.ExpiresAt,
	)
	return i, err
}

const createDeviceSignalKeys = `-- name: CreateDeviceSignalKeys :one
INSERT INTO device_signal_keys (
    device_id,
    user_id,
    identity_key,
    signed_pre_key_id,
    signed_pre_key,
    signed_pre_key_signature
) VALUES (
             $1, $2, $3, $4, $5, $6
         )
RETURNING device_id, user_id, identity_key, signed_pre_key_id, signed_pre_key, signed_pre_key_signature, created_at, last_refilled_at
`

type CreateDeviceSignalKeysParams struct {
	DeviceID              int64  `json:"device_id"`
	UserID                int32  `json:"user_id"`
	IdentityKey           []byte `json:"identity_key"`
	SignedPreKeyID        int16  `json:"signed_pre_key_id"`
	SignedPreKey          []byte `json:"signed_pre_key"`
	SignedPreKeySignature []byte `json:"signed_pre_key_signature"`
}

func (q *Queries) CreateDeviceSignalKeys(ctx context.Context, arg CreateDeviceSignalKeysParams) (DeviceSignalKey, error) {
	row := q.db.QueryRow(ctx, createDeviceSignalKeys,
		arg.DeviceID,
		arg.UserID,
		arg.IdentityKey,
		arg.SignedPreKeyID,
		arg.SignedPreKey,
		arg.SignedPreKeySignature,
	)
	var i DeviceSignalKey
	err := row.Scan(
		&i.DeviceID,
		&i.UserID,
		&i.IdentityKey,
		&i.SignedPreKeyID,
		&i.SignedPreKey,
		&i.SignedPreKeySignature,
		&i.CreatedAt,
		&i.LastRefilledAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one


INSERT INTO "user" (
    email,
    password_hash,
    password_algo,
    name
) VALUES ($1, $2, $3, $4)
RETURNING id, email, password_hash, password_algo, password_updated_at, name, last_login_at, last_active_at, created_at
`

type CreateUserParams struct {
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
	PasswordAlgo int16  `json:"password_algo"`
	Name         string `json:"name"`
}

// queries.sql
// --
// User Management
// --
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.PasswordHash,
		arg.PasswordAlgo,
		arg.Name,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.PasswordAlgo,
		&i.PasswordUpdatedAt,
		&i.Name,
		&i.LastLoginAt,
		&i.LastActiveAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM "user"
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getChatByID = `-- name: GetChatByID :one
SELECT id, type, visibility, post_policy, status, moderation_policy, encryption, name, name_fts, tags, topic, description, settings, created_by, created_at, parent_id, expires_at, threads_enabled FROM chat
WHERE id = $1
`

func (q *Queries) GetChatByID(ctx context.Context, id int32) (Chat, error) {
	row := q.db.QueryRow(ctx, getChatByID, id)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Visibility,
		&i.PostPolicy,
		&i.Status,
		&i.ModerationPolicy,
		&i.Encryption,
		&i.Name,
		&i.NameFts,
		&i.Tags,
		&i.Topic,
		&i.Description,
		&i.Settings,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ParentID,
		&i.ExpiresAt,
		&i.ThreadsEnabled,
	)
	return i, err
}

const getChatParticipant = `-- name: GetChatParticipant :one
SELECT chat_id, user_id, chat_type, role, permissions_bitmask, joined_at, rejoined_at, left_at, ban_reason, ban_type, banned_by, banned_until, ban_reason_note, invited_by, invited_at, last_read_message_id, last_read_at, muted_until, notification_level, custom_nickname, color_theme, settings, is_pinned, last_pinned_message_id FROM chat_participant
WHERE chat_id = $1 AND user_id = $2
`

type GetChatParticipantParams struct {
	ChatID int32 `json:"chat_id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) GetChatParticipant(ctx context.Context, arg GetChatParticipantParams) (ChatParticipant, error) {
	row := q.db.QueryRow(ctx, getChatParticipant, arg.ChatID, arg.UserID)
	var i ChatParticipant
	err := row.Scan(
		&i.ChatID,
		&i.UserID,
		&i.ChatType,
		&i.Role,
		&i.PermissionsBitmask,
		&i.JoinedAt,
		&i.RejoinedAt,
		&i.LeftAt,
		&i.BanReason,
		&i.BanType,
		&i.BannedBy,
		&i.BannedUntil,
		&i.BanReasonNote,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.LastReadMessageID,
		&i.LastReadAt,
		&i.MutedUntil,
		&i.NotificationLevel,
		&i.CustomNickname,
		&i.ColorTheme,
		&i.Settings,
		&i.IsPinned,
		&i.LastPinnedMessageID,
	)
	return i, err
}

const getChatParticipants = `-- name: GetChatParticipants :many
SELECT
    u.id as user_id,
    u.name,
    cp.role,
    cp.custom_nickname,
    cp.joined_at
FROM chat_participant AS cp
         JOIN "user" AS u ON cp.user_id = u.id
WHERE
    cp.chat_id = $1
  AND cp.left_at IS NULL
ORDER BY cp.role, cp.joined_at
`

type GetChatParticipantsRow struct {
	UserID         int32                   `json:"user_id"`
	Name           string                  `json:"name"`
	Role           ChatParticipantRoleEnum `json:"role"`
	CustomNickname pgtype.Text             `json:"custom_nickname"`
	JoinedAt       pgtype.Timestamptz      `json:"joined_at"`
}

// Gets all current participants of a chat.
func (q *Queries) GetChatParticipants(ctx context.Context, chatID int32) ([]GetChatParticipantsRow, error) {
	rows, err := q.db.Query(ctx, getChatParticipants, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatParticipantsRow
	for rows.Next() {
		var i GetChatParticipantsRow
		if err := rows.Scan(
			&i.UserID,
			&i.Name,
			&i.Role,
			&i.CustomNickname,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserActiveDevices = `-- name: GetUserActiveDevices :many
SELECT id, user_id, name, role, fingerprint, created_at, last_seen_at, expires_at FROM chatting_device
WHERE user_id = $1 AND expires_at > NOW()
ORDER BY role, created_at
`

func (q *Queries) GetUserActiveDevices(ctx context.Context, userID int32) ([]ChattingDevice, error) {
	rows, err := q.db.Query(ctx, getUserActiveDevices, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChattingDevice
	for rows.Next() {
		var i ChattingDevice
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Role,
			&i.Fingerprint,
			&i.CreatedAt,
			&i.LastSeenAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, password_algo, password_updated_at, name, last_login_at, last_active_at, created_at FROM "user"
WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.PasswordAlgo,
		&i.PasswordUpdatedAt,
		&i.Name,
		&i.LastLoginAt,
		&i.LastActiveAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password_hash, password_algo, password_updated_at, name, last_login_at, last_active_at, created_at FROM "user"
WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.PasswordAlgo,
		&i.PasswordUpdatedAt,
		&i.Name,
		&i.LastLoginAt,
		&i.LastActiveAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserChats = `-- name: GetUserChats :many
SELECT c.id, c.type, c.visibility, c.post_policy, c.status, c.moderation_policy, c.encryption, c.name, c.name_fts, c.tags, c.topic, c.description, c.settings, c.created_by, c.created_at, c.parent_id, c.expires_at, c.threads_enabled
FROM chat c
         JOIN chat_participant cp ON c.id = cp.chat_id
WHERE
    cp.user_id = $1
  AND cp.left_at IS NULL
ORDER BY cp.is_pinned DESC, cp.last_read_at ASC NULLS FIRST
`

// Gets all non-left chats for a given user.
func (q *Queries) GetUserChats(ctx context.Context, userID int32) ([]Chat, error) {
	rows, err := q.db.Query(ctx, getUserChats, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chat
	for rows.Next() {
		var i Chat
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Visibility,
			&i.PostPolicy,
			&i.Status,
			&i.ModerationPolicy,
			&i.Encryption,
			&i.Name,
			&i.NameFts,
			&i.Tags,
			&i.Topic,
			&i.Description,
			&i.Settings,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ParentID,
			&i.ExpiresAt,
			&i.ThreadsEnabled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSignalPreKeyBundle = `-- name: GetUserSignalPreKeyBundle :many
SELECT get_user_signal_pre_key_bundle FROM get_user_signal_pre_key_bundle($1, $2, $3)
`

type GetUserSignalPreKeyBundleParams struct {
	PSenderID   int32 `json:"p_sender_id"`
	PReceiverID int32 `json:"p_receiver_id"`
	PChatID     int32 `json:"p_chat_id"`
}

// This demonstrates how to call the custom function you defined.
func (q *Queries) GetUserSignalPreKeyBundle(ctx context.Context, arg GetUserSignalPreKeyBundleParams) ([]sql.NullString, error) {
	rows, err := q.db.Query(ctx, getUserSignalPreKeyBundle, arg.PSenderID, arg.PReceiverID, arg.PChatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var get_user_signal_pre_key_bundle sql.NullString
		if err := rows.Scan(&get_user_signal_pre_key_bundle); err != nil {
			return nil, err
		}
		items = append(items, get_user_signal_pre_key_bundle)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeChatParticipant = `-- name: RemoveChatParticipant :exec
DELETE FROM chat_participant
WHERE chat_id = $1 AND user_id = $2
`

type RemoveChatParticipantParams struct {
	ChatID int32 `json:"chat_id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) RemoveChatParticipant(ctx context.Context, arg RemoveChatParticipantParams) error {
	_, err := q.db.Exec(ctx, removeChatParticipant, arg.ChatID, arg.UserID)
	return err
}

const searchPublicGroupChatsByName = `-- name: SearchPublicGroupChatsByName :many
SELECT id, name, topic, description, tags FROM chat
WHERE
    name_fts @@ to_tsquery('english', $1)
  AND type = 'group'
  AND visibility = 'public'
  AND status = 'active'
ORDER BY
    ts_rank(name_fts, to_tsquery('english', $1)) DESC
LIMIT 20
`

type SearchPublicGroupChatsByNameRow struct {
	ID          int32       `json:"id"`
	Name        pgtype.Text `json:"name"`
	Topic       pgtype.Text `json:"topic"`
	Description pgtype.Text `json:"description"`
	Tags        []string    `json:"tags"`
}

// This uses the Full-Text Search index on the `name` column.
func (q *Queries) SearchPublicGroupChatsByName(ctx context.Context, toTsquery string) ([]SearchPublicGroupChatsByNameRow, error) {
	rows, err := q.db.Query(ctx, searchPublicGroupChatsByName, toTsquery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchPublicGroupChatsByNameRow
	for rows.Next() {
		var i SearchPublicGroupChatsByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Topic,
			&i.Description,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChatTopic = `-- name: UpdateChatTopic :exec
UPDATE chat
SET topic = $1
WHERE id = $2
`

type UpdateChatTopicParams struct {
	Topic pgtype.Text `json:"topic"`
	ID    int32       `json:"id"`
}

func (q *Queries) UpdateChatTopic(ctx context.Context, arg UpdateChatTopicParams) error {
	_, err := q.db.Exec(ctx, updateChatTopic, arg.Topic, arg.ID)
	return err
}

const updateDeviceLastSeen = `-- name: UpdateDeviceLastSeen :one
UPDATE chatting_device
SET last_seen_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING expires_at
`

type UpdateDeviceLastSeenParams struct {
	ID     int64 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) UpdateDeviceLastSeen(ctx context.Context, arg UpdateDeviceLastSeenParams) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, updateDeviceLastSeen, arg.ID, arg.UserID)
	var expires_at pgtype.Timestamptz
	err := row.Scan(&expires_at)
	return expires_at, err
}

const updateParticipantLastRead = `-- name: UpdateParticipantLastRead :exec
UPDATE chat_participant
SET
    last_read_message_id = $1,
    last_read_at = NOW()
WHERE
    chat_id = $2 AND user_id = $3
`

type UpdateParticipantLastReadParams struct {
	LastReadMessageID pgtype.UUID `json:"last_read_message_id"`
	ChatID            int32       `json:"chat_id"`
	UserID            int32       `json:"user_id"`
}

func (q *Queries) UpdateParticipantLastRead(ctx context.Context, arg UpdateParticipantLastReadParams) error {
	_, err := q.db.Exec(ctx, updateParticipantLastRead, arg.LastReadMessageID, arg.ChatID, arg.UserID)
	return err
}

const updateParticipantRole = `-- name: UpdateParticipantRole :one
UPDATE chat_participant
SET
    role = $1,
    permissions_bitmask = $2
WHERE
    chat_id = $3 AND user_id = $4
RETURNING chat_id, user_id, chat_type, role, permissions_bitmask, joined_at, rejoined_at, left_at, ban_reason, ban_type, banned_by, banned_until, ban_reason_note, invited_by, invited_at, last_read_message_id, last_read_at, muted_until, notification_level, custom_nickname, color_theme, settings, is_pinned, last_pinned_message_id
`

type UpdateParticipantRoleParams struct {
	Role               ChatParticipantRoleEnum `json:"role"`
	PermissionsBitmask pgtype.Bits             `json:"permissions_bitmask"`
	ChatID             int32                   `json:"chat_id"`
	UserID             int32                   `json:"user_id"`
}

func (q *Queries) UpdateParticipantRole(ctx context.Context, arg UpdateParticipantRoleParams) (ChatParticipant, error) {
	row := q.db.QueryRow(ctx, updateParticipantRole,
		arg.Role,
		arg.PermissionsBitmask,
		arg.ChatID,
		arg.UserID,
	)
	var i ChatParticipant
	err := row.Scan(
		&i.ChatID,
		&i.UserID,
		&i.ChatType,
		&i.Role,
		&i.PermissionsBitmask,
		&i.JoinedAt,
		&i.RejoinedAt,
		&i.LeftAt,
		&i.BanReason,
		&i.BanType,
		&i.BannedBy,
		&i.BannedUntil,
		&i.BanReasonNote,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.LastReadMessageID,
		&i.LastReadAt,
		&i.MutedUntil,
		&i.NotificationLevel,
		&i.CustomNickname,
		&i.ColorTheme,
		&i.Settings,
		&i.IsPinned,
		&i.LastPinnedMessageID,
	)
	return i, err
}

const updateUserActivity = `-- name: UpdateUserActivity :exec
UPDATE "user"
SET
    last_login_at = $1,
    last_active_at = $2
WHERE
    id = $3
`

type UpdateUserActivityParams struct {
	LastLoginAt  pgtype.Timestamptz `json:"last_login_at"`
	LastActiveAt pgtype.Timestamptz `json:"last_active_at"`
	ID           int32              `json:"id"`
}

func (q *Queries) UpdateUserActivity(ctx context.Context, arg UpdateUserActivityParams) error {
	_, err := q.db.Exec(ctx, updateUserActivity, arg.LastLoginAt, arg.LastActiveAt, arg.ID)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE "user"
SET
    password_hash = $1,
    password_algo = $2
WHERE
    id = $3
`

type UpdateUserPasswordParams struct {
	PasswordHash string `json:"password_hash"`
	PasswordAlgo int16  `json:"password_algo"`
	ID           int32  `json:"id"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.PasswordHash, arg.PasswordAlgo, arg.ID)
	return err
}

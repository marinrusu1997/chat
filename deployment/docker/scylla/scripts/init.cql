-- =================================================================
--  ScyllaDB One-Time Initialization Script
-- =================================================================
-- This script is idempotent and can be run safely multiple times.

-- @fixme use https://github.com/scylladb/scylla-monitoring for monitoring
-- @fixme a good guide https://youtu.be/P6UkQJrEQyU?si=xtPNR1SDsxYy5xj-

CREATE KEYSPACE IF NOT EXISTS chat_db
    WITH replication = {
        'class': 'NetworkTopologyStrategy',
        'DC1': 3
    }
    AND TABLETS = {'enabled': true}
    AND durable_writes = true;

USE chat_db;

CREATE TABLE IF NOT EXISTS schema_versions (
    script_name TEXT PRIMARY KEY,
    applied_at TIMESTAMP,
);

-- Concern	                    Where it lives	                                        Reason
-- Which chat is a thread	    Postgres metadata (sub_chat_id, parent_chat_id)	        Threads are a structural property of the chat itself,
--                                                                                      not high-throughput data.
-- Messages in a thread	        ScyllaDB messages_by_chat with chat_id = sub_chat_id	Threads are just “sub-chats” for storage;
--                                                                                      high-throughput writes and reads go here.
-- Reply chain inside a thread	`reply_to_message_id` in ScyllaDB	                    Lets you display “in reply to” previews inside the thread.

-- @fixme TWCS requires immutable tables with fixed TTL: https://docs.scylladb.com/manual/stable/cql/compaction.html#time-window-compactionstrategy-twcs
CREATE TABLE IF NOT EXISTS messages_by_chat (
    chat_id UUID,
    message_id TIMEUUID,              -- clustering key for ordering, must be generated by client for idempotency
                                      -- for scheduled messages, the worker generates TIMEUUID based on the current time, the true sending time.
    day_bucket DATE,                  -- partition by day to avoid hot partitions
    sender_id UUID,
    message_type ASCII,                -- e.g., 'text', 'system', 'poll', 'attachment', 'audio', 'video'
    content TEXT, -- for compliance with TWCS, we "UPDATE" the Message with an INSERT
    client_metadata FROZEN<MAP<ASCII, ASCII>>,  -- e.g., {'client_message_id': 'abc123', 'device': 'iOS'}
    reply_to_message_id TIMEUUID,
    forwarded_from_message_id TIMEUUID,
    edited_at TIMESTAMP, -- for compliance with TWCS, we "UPDATE" the Message with an INSERT
    deleted_at TIMESTAMP, -- for compliance with TWCS, we "DELETE" the Message with an INSERT
    expires_at  TIMESTAMP, -- for compliance with TWCS, we "DELETE" the Message with an INSERT
    scheduled_at TIMESTAMP, -- for scheduled messages

    PRIMARY KEY ((chat_id, day_bucket), message_id)
) WITH CLUSTERING ORDER BY (message_id DESC)
    AND comment = '
        Purpose: Primary, time-ordered store for all message data. Acts as the source of truth.
        I/O Pattern: Extremely write-heavy, with reads being time-range scans for recent messages.
        Compaction: TWCS is used for efficient, time-based data expiration.
        TTL: 90 days. This is the master retention policy for all ephemeral data.
        Deps: Writes to this table trigger dual-writes to messages_by_id and fan-out updates to inbox_by_user.'
    AND compaction = {
        'class': 'TimeWindowCompactionStrategy',
        'compaction_window_unit': 'DAYS',
        'compaction_window_size': 2 -- @fixme do not update data outside of this window (i.e. updates are oly for recent messages which age < 2 days)
    }
    -- AND compression = {'sstable_compression': 'LZ4Compressor'}
    -- AND tablet_options = { 'expected_data_size_in_gb': 1000 }
    -- AND caching = {'enabled': true}
    AND default_time_to_live = 7776000 -- 90 days for retention
    AND tombstone_gc = {'mode':'repair'}; -- we might "UPDATE" or "DELETE" a Message, so we need a more conservative GC strategy
    -- AND cdc = { 'enabled': true, 'ttl': 86400, 'preimage': false }; -- useful for event sourcing and audit logs. See issue #16317.

-- @fixme TWCS requires immutable tables with fixed TTL: https://docs.scylladb.com/manual/stable/cql/compaction.html#time-window-compactionstrategy-twcs
CREATE TABLE IF NOT EXISTS messages_by_id (
    message_id TIMEUUID PRIMARY KEY,
    chat_id UUID,
    sender_id UUID,
    message_type ASCII,
    content TEXT, -- for compliance with TWCS, we "UPDATE" the Message with an INSERT
    reply_to_message_id TIMEUUID,
    forwarded_from_message_id TIMEUUID,
    edited_at TIMESTAMP, -- for compliance with TWCS, we "UPDATE" the Message with an INSERT
    deleted_at TIMESTAMP, -- for compliance with TWCS, we "DELETE" the Message with an INSERT
    expires_at  TIMESTAMP, -- for compliance with TWCS, we "DELETE" the Message with an INSERT
) WITH
    comment = '
        Purpose: A manual index to provide fast, global lookups of a single message by its ID.
        I/O Pattern: Write-heavy (mirrors messages_by_chat) with less frequent, random reads by primary key.
        Compaction: ICS is used as it is optimized for write-heavy lookup workloads.
        TTL: 90 days, synchronized with the base messages_by_chat table to prevent orphaned index entries.
        Deps: Receives a 1-to-1 dual-write for every insert into messages_by_chat.'
    AND compaction = {
            'class': 'IncrementalCompactionStrategy',
            'min_sstable_size': 33554432, -- 32MB in bytes
            'sstable_size_in_mb': 256,
            'space_amplification_goal': 1.25
    }
    -- AND compression = {'sstable_compression': 'LZ4Compressor'}
    -- AND tablet_options = { 'expected_data_size_in_gb': 1000 }
    AND bloom_filter_fp_chance = 0.005
    -- AND caching = {'enabled': true}
    AND default_time_to_live = 7776000 -- 90 days for retention
    AND tombstone_gc = {'mode':'repair'};

CREATE TABLE IF NOT EXISTS pinned_messages_by_chat (
    chat_id UUID,
    message_id TIMEUUID,
    pinned_at TIMESTAMP,
    pinner_id UUID,
    message_content_preview TEXT, -- Truncated preview for quick display
    PRIMARY KEY ((chat_id), pinned_at, message_id)
) WITH CLUSTERING ORDER BY (pinned_at DESC)
    AND comment = '
        Purpose: Stores a curated list of important messages for a chat, displayed prominently in the UI.
        I/O Pattern: Very read-heavy with infrequent writes, only when a moderator pins or unpins.
        Compaction: LCS is used to guarantee the lowest possible read latency for this critical UI element.
        TTL: None. The lifecycle of a pin is managed by explicit user action, not by time.'
    AND speculative_retry = '97PERCENTILE'
    AND compaction = {
        'class': 'LeveledCompactionStrategy',
        'sstable_size_in_mb': 150
    }
    AND tombstone_gc = {'mode':'repair'};
    -- AND compression = {'sstable_compression': 'LZ4Compressor'}
    -- AND caching = {'enabled': true};

CREATE TABLE IF NOT EXISTS mentions_by_user (
    mentioned_user_id UUID,
    day_bucket DATE,              -- To avoid hot partitions for popular users
    message_id TIMEUUID,
    chat_id UUID,
    sender_id UUID,
    message_content_preview TEXT, -- Truncated preview for quick display
    PRIMARY KEY ((mentioned_user_id, day_bucket), message_id)
) WITH CLUSTERING ORDER BY (message_id DESC)
    AND comment = '
        Purpose: Powers the user''s notification inbox, showing all messages where they were mentioned.
        I/O Pattern: Read-heavy when a user checks their notifications. Writes are moderately frequent.
        Compaction: LCS is used to prioritize a fast, responsive user experience for the notification screen.
        TTL: 90 days. A sensible retention policy for ephemeral notification data.
        Deps: Populated when a message containing a mention is sent.'
    AND speculative_retry = '97PERCENTILE'
    AND compaction = {
       'class': 'LeveledCompactionStrategy',
       'sstable_size_in_mb': 150
    }
    -- AND compression = {'sstable_compression': 'LZ4Compressor'}
    -- AND caching = {'enabled': true}
    AND default_time_to_live = 7776000 -- 90 days for retention
    AND tombstone_gc = {'mode':'repair'};
CREATE INDEX IF NOT EXISTS mentions_by_chat_idx ON mentions_by_user ((mentioned_user_id, day_bucket), chat_id); -- for fetching mentions in a specific chat

--------------------------------------------------------
-- Receipt type	    Storage	                            Reason
-- Sent	            No storage needed	                Sending user gets immediate acknowledgement after the message is written
--                                                      to ScyllaDB (messages_by_chat).
-- Delivered	    Ephemeral store (Redis)	            Only needed to track messages that have been delivered to a recipient
--                                                      but not yet read. High-write, high-turnover data — perfect for Redis.
-- Read	            chat_read_state table in ScyllaDB	Tracks last read message per user per chat. Scales well, no hot partition issues.
--------------------------------------------------------
CREATE TABLE IF NOT EXISTS read_receipts_by_user (
    chat_id UUID,
    user_id UUID,
    last_read_message_id TIMEUUID,
    last_read_at TIMESTAMP,
    PRIMARY KEY ((user_id), chat_id)
) WITH
    comment = '
        Purpose: Tracks the last-read message marker for each user in each chat to manage unread status.
        I/O Pattern: Very write-heavy (updated frequently as users read messages), with important but less frequent reads on app connect/resume.
        Compaction: ICS is used to efficiently handle the high write volume, providing a better balance than LCS for this workload.
        TTL: None. A user''s read state must be permanent to avoid them losing their position in a chat.'
    AND speculative_retry = '97PERCENTILE'
    AND compaction = {
        'class': 'IncrementalCompactionStrategy',
        'min_sstable_size': 10485760, -- 10MB
        'space_amplification_goal': 1.25
    }
    AND tombstone_gc = {'mode':'repair'};
    -- AND compression = {'sstable_compression': 'LZ4Compressor'};
    -- AND caching = {'enabled': true};

CREATE TABLE IF NOT EXISTS inbox_by_user (
    user_id UUID,
    chat_id UUID,
    chat_display_name TEXT,
    chat_avatar_url TEXT,
    chat_type ASCII,
    last_message_id TIMEUUID,
    last_message_content_preview TEXT, -- Truncated preview for quick display
    last_message_sender_id UUID,
    updated_at TIMESTAMP,
    PRIMARY KEY ((user_id), updated_at, chat_id)
) WITH CLUSTERING ORDER BY (updated_at DESC)
    AND comment = '
        Purpose: Powers the main chat list (inbox) for each user. This is a denormalized view.
        I/O Pattern: A challenging mixed workload. Very write-heavy (fan-out on every message) and very read-heavy (on every app open).
        Compaction: ICS is used to provide the best balance for this high-throughput mixed workload.
        TTL: None. A user''s list of chats must be permanent, only removed by explicit user action (e.g., leaving a chat).
        Deps: Updated by a fan-out mechanism for all participants whenever a new message is sent in a chat.'
    AND speculative_retry = '97PERCENTILE'
    AND compaction = {
        'class': 'IncrementalCompactionStrategy',
        'min_sstable_size': 16777216, -- 16MB in bytes
        'space_amplification_goal': 1.25
    }
    -- AND compression = {'sstable_compression': 'LZ4Compressor'}
    -- AND caching = {'enabled': true}
    AND tombstone_gc = {'mode':'repair'};
CREATE INDEX IF NOT EXISTS inbox_by_chat_idx on inbox_by_user ((user_id), chat_id); -- for quick lookups when updating the chat related columns

-- @fixme We need to actually delete this data when the attachment is deleted or expires.
CREATE TABLE IF NOT EXISTS attachments_by_id (
    attachment_id UUID PRIMARY KEY,
    message_id TIMEUUID,
    chat_id UUID,
    sender_id UUID,
    filename TEXT,
    url TEXT,
    mime_type ASCII,
    size_bytes INT,
    thumbnail_url TEXT,
    width SMALLINT,
    height SMALLINT,
    uploaded_at TIMESTAMP,
) WITH
    comment = '
        Purpose: A global lookup table to find attachment metadata by its unique ID.
        I/O Pattern: Write-once (per attachment), with random reads when a user accesses a specific attachment.
        Compaction: ICS is a modern, efficient choice for a write-heavy lookup table.
        TTL: 90 days. Synchronized with the message lifecycle to prevent orphaned data.
        Deps: Populated when a message with an attachment is sent. Requires an application-level job for cleanup.'
    AND compaction = {
        'class': 'IncrementalCompactionStrategy',
        'min_sstable_size': 10485760, -- 10MB
        'space_amplification_goal': 1.25
    }
    -- AND compression = {'sstable_compression': 'LZ4Compressor'}
    AND bloom_filter_fp_chance = 0.005
    -- AND caching = {'enabled': true}
    AND default_time_to_live = 7776000 -- 90 days for retention
    AND tombstone_gc = {'mode':'repair'};

-- @fixme TWCS requires immutable tables with fixed TTL: https://docs.scylladb.com/manual/stable/cql/compaction.html#time-window-compactionstrategy-twcs
-- @fixme this table should actually never change
CREATE TABLE IF NOT EXISTS attachments_by_chat (
    attachment_id UUID,
    message_id TIMEUUID,
    chat_id UUID,
    sender_id UUID,
    filename TEXT,
    url TEXT,
    mime_type ASCII,
    size_bytes INT,
    thumbnail_url TEXT,
    width SMALLINT,
    height SMALLINT,
    uploaded_at TIMESTAMP,
    deleted_at TIMESTAMP, -- for compliance with TWCS, we "DELETE" the Attachment with an INSERT
    PRIMARY KEY ((chat_id), message_id, attachment_id)
) WITH CLUSTERING ORDER BY (message_id DESC)
    AND comment = '
        Purpose: The time-ordered store for attachment metadata within a chat, powering the "Media Gallery".
        I/O Pattern: Write-heavy, with reads being time-range scans.
        Compaction: TWCS is used as this is time-series data that expires along with its parent message.
        TTL: 90 days. Synchronized with the messages_by_chat retention policy.
        Deps: Populated when a message with an attachment is sent.'
    AND compaction = {
        'class': 'TimeWindowCompactionStrategy',
        'compaction_window_unit': 'DAYS',
        'compaction_window_size': 2 -- @fixme do not update data outside of this window (i.e. updates are oly for recent attachments which age < 2 days)
    }
    -- AND compression = {'sstable_compression': 'LZ4Compressor'}
    -- AND caching = {'enabled': true}
    AND default_time_to_live = 7776000 -- 90 days for retention
    AND tombstone_gc = {'mode':'immediate'}
    AND per_partition_rate_limit = {'max_writes_per_second': 100};

CREATE TABLE IF NOT EXISTS reactions_by_message (
    message_id TIMEUUID,
    reactor_id UUID,
    reaction_emoji TEXT,
    reacted_at TIMESTAMP,
    PRIMARY KEY ((message_id), reactor_id, reaction_emoji)
) WITH CLUSTERING ORDER BY (reactor_id ASC, reaction_emoji ASC)
    AND comment = '
        Purpose: Stores all reactions for a given message.
        I/O Pattern: Very read-heavy (read every time the message is displayed), with moderate writes.
        Compaction: LCS is the best choice to ensure reactions display instantly with minimal latency.
        TTL: 90 days. Synchronized with the message lifecycle to prevent orphaned reactions.
        Deps: Populated by user actions on a specific message.'
    AND speculative_retry = '97PERCENTILE'
    AND compaction = {
        'class': 'LeveledCompactionStrategy',
        'sstable_size_in_mb': 150
    }
    -- AND compression = {'sstable_compression': 'LZ4Compressor'}
    -- AND caching = {'enabled': true}
    AND default_time_to_live = 7776000 -- 90 days for retention
    AND tombstone_gc = {'mode':'repair'};



-- Define a custom data type to hold the running sum and count
CREATE TYPE avg_state (sum int, count int);

-- Define the state function
CREATE OR REPLACE FUNCTION avg_sfunc(state avg_state, val text)
    RETURNS NULL ON NULL INPUT
    RETURNS avg_state
    LANGUAGE LUA AS '
  state.sum = state.sum + string.len(val)
  state.count = state.count + 1
  return state
';

-- Define the final function
CREATE OR REPLACE FUNCTION avg_finalfunc(state avg_state)
    RETURNS NULL ON NULL INPUT
    RETURNS double
    LANGUAGE LUA AS '
  return state.sum / state.count
';

-- Create the aggregate
CREATE OR REPLACE AGGREGATE average_message_length(text)
    SFUNC avg_sfunc
    STYPE avg_state
    FINALFUNC avg_finalfunc
    INITCOND { sum: 0, count: 0 };
-- =================================================================
--  ScyllaDB One-Time Initialization Script
-- =================================================================
-- This script is idempotent and can be run safely multiple times.

CREATE KEYSPACE IF NOT EXISTS chat_app
    WITH replication = {
        'class': 'NetworkTopologyStrategy',
        'DC1': 3
    }
    AND TABLETS = {'enabled': true}
    AND durable_writes = true;

USE chat_app;

CREATE TABLE IF NOT EXISTS schema_versions (
    script_name TEXT PRIMARY KEY,
    applied_at TIMESTAMP,
);

-- Concern	                    Where it lives	                                        Reason
-- Which chat is a thread	    Postgres metadata (sub_chat_id, parent_chat_id)	        Threads are a structural property of the chat itself,
--                                                                                      not high-throughput data.
-- Messages in a thread	        ScyllaDB messages_by_chat with chat_id = sub_chat_id	Threads are just “sub-chats” for storage;
--                                                                                      high-throughput writes and reads go here.
-- Reply chain inside a thread	`reply_to_message_id` in ScyllaDB	                    Lets you display “in reply to” previews inside the thread.

-- @fixme TWCS requires immutable tables with fixed TTL: https://docs.scylladb.com/manual/stable/cql/compaction.html#time-window-compactionstrategy-twcs
CREATE TABLE IF NOT EXISTS messages_by_chat (
    chat_id UUID,
    message_id TIMEUUID,              -- clustering key for ordering, must be generated by client for idempotency
                                      -- for scheduled messages, the worker generates TIMEUUID based on the current time, the true sending time.
    day_bucket DATE,                  -- partition by day to avoid hot partitions
    sender_id UUID,
    message_type ASCII,                -- e.g., 'text', 'system', 'poll', 'attachment', 'audio', 'video'
    content TEXT, -- for compliance with TWCS, we "UPDATE" the Message with an INSERT
    client_metadata FROZEN<MAP<ASCII, ASCII>>,  -- e.g., {'client_message_id': 'abc123', 'device': 'iOS'}
    reply_to_message_id TIMEUUID,
    forwarded_from_message_id TIMEUUID,
    edited_at TIMESTAMP, -- for compliance with TWCS, we "UPDATE" the Message with an INSERT
    deleted_at TIMESTAMP, -- for compliance with TWCS, we "DELETE" the Message with an INSERT
    expires_at  TIMESTAMP, -- for compliance with TWCS, we "DELETE" the Message with an INSERT
    scheduled_at TIMESTAMP, -- for scheduled messages

    PRIMARY KEY ((chat_id, day_bucket), message_id)
) WITH CLUSTERING ORDER BY (message_id DESC)
    AND comment = 'Primary message store, partitioned by chat and day. Optimized for writing and fetching recent messages.'
    AND compaction = {
        'class': 'TimeWindowCompactionStrategy',
        'compaction_window_unit': 'DAYS',
        'compaction_window_size': 2
    }
    -- AND compression = {'sstable_compression': 'LZ4Compressor'}
    -- AND tablet_options = { 'expected_data_size_in_gb': 1000 }
    -- AND caching = {'enabled': true}
    AND default_time_to_live = 7776000 -- 90 days for retention
    AND tombstone_gc = {'mode':'immediate'};
    -- AND cdc = { 'enabled': true, 'ttl': 86400, 'preimage': false }; -- useful for event sourcing and audit logs. See issue #16317.

-- @fixme TWCS requires immutable tables with fixed TTL: https://docs.scylladb.com/manual/stable/cql/compaction.html#time-window-compactionstrategy-twcs
CREATE TABLE IF NOT EXISTS messages_by_id (
    message_id TIMEUUID PRIMARY KEY,
    chat_id UUID,
    sender_id UUID,
    message_type ASCII,
    content TEXT, -- for compliance with TWCS, we "UPDATE" the Message with an INSERT
    reply_to_message_id TIMEUUID,
    forwarded_from_message_id TIMEUUID,
    edited_at TIMESTAMP, -- for compliance with TWCS, we "UPDATE" the Message with an INSERT
    deleted_at TIMESTAMP, -- for compliance with TWCS, we "DELETE" the Message with an INSERT
    expires_at  TIMESTAMP, -- for compliance with TWCS, we "DELETE" the Message with an INSERT
) WITH
    comment = 'Manual index (dual-write table) for looking up a message by its ID. Data lifecycle mirrors messages_by_chat.'
    AND compaction = {
        'class': 'TimeWindowCompactionStrategy',
        'compaction_window_unit': 'DAYS',
        'compaction_window_size': 2
    }
    -- AND compression = {'sstable_compression': 'LZ4Compressor'}
    -- AND tablet_options = { 'expected_data_size_in_gb': 1000 }
    AND bloom_filter_fp_chance = 0.005
    -- AND caching = {'enabled': true}
    AND default_time_to_live = 7776000 -- 90 days for retention
    AND tombstone_gc = {'mode':'immediate'};

CREATE TABLE IF NOT EXISTS pinned_messages_by_chat (
    chat_id UUID,
    pinned_at TIMESTAMP,
    message_id TIMEUUID,
    pinner_id UUID,
    message_content_preview TEXT, -- Truncated preview for quick display
    PRIMARY KEY ((chat_id), pinned_at, message_id)
) WITH CLUSTERING ORDER BY (pinned_at DESC)
    AND comment = 'Stores global pinned messages for a chat, ordered by when they were pinned. Read-heavy.'
    AND speculative_retry = '97PERCENTILE'
    AND compaction = {
        'class': 'LeveledCompactionStrategy',
        'sstable_size_in_mb': 150
    };
    -- AND compression = {'sstable_compression': 'LZ4Compressor'}
    -- AND caching = {'enabled': true};

CREATE TABLE IF NOT EXISTS mentions_by_user (
    mentioned_user_id UUID,
    day_bucket DATE,              -- To avoid hot partitions for popular users
    message_id TIMEUUID,
    chat_id UUID,
    sender_id UUID,
    message_content_preview TEXT, -- Truncated preview for quick display
    PRIMARY KEY ((mentioned_user_id, day_bucket), message_id)
) WITH CLUSTERING ORDER BY (message_id DESC)
    AND comment = 'Stores user mentions to power the notifications inbox. Read-heavy for recent mentions.'
    AND speculative_retry = '97PERCENTILE'
    AND compaction = {
       'class': 'LeveledCompactionStrategy',
       'sstable_size_in_mb': 150
    }
    -- AND compression = {'sstable_compression': 'LZ4Compressor'}
    -- AND caching = {'enabled': true}
    AND default_time_to_live = 7776000 -- 90 days for retention
    AND tombstone_gc = {'mode':'repair'};
CREATE INDEX IF NOT EXISTS mentions_by_chat_idx ON mentions_by_user ((mentioned_user_id, day_bucket), chat_id); -- for fetching mentions in a specific chat

--------------------------------------------------------
-- Receipt type	    Storage	                            Reason
-- Sent	            No storage needed	                Sending user gets immediate acknowledgement after the message is written
--                                                      to ScyllaDB (messages_by_chat).
-- Delivered	    Ephemeral store (Redis)	            Only needed to track messages that have been delivered to a recipient
--                                                      but not yet read. High-write, high-turnover data — perfect for Redis.
-- Read	            chat_read_state table in ScyllaDB	Tracks last read message per user per chat. Scales well, no hot partition issues.
--------------------------------------------------------
CREATE TABLE IF NOT EXISTS chat_read_state (
    chat_id UUID,
    user_id UUID,
    last_read_message_id TIMEUUID,
    last_read_at TIMESTAMP,
    PRIMARY KEY ((user_id), chat_id)
) WITH
    comment = 'Tracks the last read message for each user in each chat. High-frequency reads and writes.'
    AND speculative_retry = '97PERCENTILE'
    AND compaction = {
        'class': 'LeveledCompactionStrategy',
        'sstable_size_in_mb': 150
    };
    -- AND compression = {'sstable_compression': 'LZ4Compressor'};
    -- AND caching = {'enabled': true};

CREATE TABLE IF NOT EXISTS inbox_by_user (
    user_id UUID,
    chat_id UUID,
    chat_display_name TEXT,
    chat_avatar_url TEXT,
    chat_type ASCII,
    last_message_id TIMEUUID,
    last_message_content_preview TEXT, -- Truncated preview for quick display
    last_message_sender_id UUID,
    updated_at TIMESTAMP,
    PRIMARY KEY ((user_id), updated_at, chat_id)
) WITH CLUSTERING ORDER BY (updated_at DESC)
    AND comment = 'Powers the user''s main inbox view, showing a list of their chats. Extremely read-heavy.'
    AND speculative_retry = '97PERCENTILE'
    AND compaction = {
        'class': 'LeveledCompactionStrategy',
        'sstable_size_in_mb': 300
    }
    -- AND compression = {'sstable_compression': 'LZ4Compressor'}
    -- AND caching = {'enabled': true}
    AND per_partition_rate_limit = {'max_writes_per_second': 50};
CREATE INDEX IF NOT EXISTS inbox_by_chat_idx on inbox_by_user ((user_id), chat_id); -- for quick lookups when updating the chat related columns

-- @fixme We need to actually delete this data when the attachment is deleted or expires.
CREATE TABLE IF NOT EXISTS attachments_by_id (
    attachment_id UUID PRIMARY KEY,
    message_id TIMEUUID,
    chat_id UUID,
    sender_id UUID,
    filename TEXT,
    url TEXT,
    mime_type ASCII,
    size_bytes INT,
    thumbnail_url TEXT,
    width SMALLINT,
    height SMALLINT,
    uploaded_at TIMESTAMP,
) WITH
    comment = 'Lookup table to fetch attachment metadata by its unique ID. Write-once, read-heavy on access.'
    AND compaction = {
        'class': 'IncrementalCompactionStrategy',
        'min_sstable_size': 10485760, -- 10MB
        'space_amplification_goal': 1.25
    }
    -- AND compression = {'sstable_compression': 'LZ4Compressor'}
    AND bloom_filter_fp_chance = 0.005
    -- AND caching = {'enabled': true}
    AND default_time_to_live = 7776000 -- 90 days for retention
    AND tombstone_gc = {'mode':'repair'};

-- @fixme TWCS requires immutable tables with fixed TTL: https://docs.scylladb.com/manual/stable/cql/compaction.html#time-window-compactionstrategy-twcs
CREATE TABLE IF NOT EXISTS attachments_by_chat (
    attachment_id UUID,
    message_id TIMEUUID,
    chat_id UUID,
    sender_id UUID,
    filename TEXT,
    url TEXT,
    mime_type ASCII,
    size_bytes INT,
    thumbnail_url TEXT,
    width SMALLINT,
    height SMALLINT,
    uploaded_at TIMESTAMP,
    deleted_at TIMESTAMP, -- for compliance with TWCS, we "DELETE" the Attachment with an INSERT
    PRIMARY KEY ((chat_id), message_id, attachment_id)
) WITH CLUSTERING ORDER BY (message_id DESC)
    AND comment = 'Time-series store of attachments sent in a chat, ordered by message time.'
    AND compaction = {
        'class': 'TimeWindowCompactionStrategy',
        'compaction_window_unit': 'DAYS',
        'compaction_window_size': 2
    }
    -- AND compression = {'sstable_compression': 'LZ4Compressor'}
    -- AND caching = {'enabled': true}
    AND default_time_to_live = 7776000 -- 90 days for retention
    AND tombstone_gc = {'mode':'immediate'};

CREATE TABLE IF NOT EXISTS reactions_by_message (
    message_id TIMEUUID,
    reactor_id UUID,
    reaction_emoji TEXT,
    reacted_at TIMESTAMP,
    PRIMARY KEY ((message_id), reactor_id, reaction_emoji)
) WITH CLUSTERING ORDER BY (reactor_id ASC, reaction_emoji ASC)
    AND comment = 'Stores all reactions for a given message. Highly read-heavy.'
    AND speculative_retry = '97PERCENTILE'
    AND compaction = {
        'class': 'LeveledCompactionStrategy',
        'sstable_size_in_mb': 150
    }
    -- AND compression = {'sstable_compression': 'LZ4Compressor'}
    -- AND caching = {'enabled': true}
    AND default_time_to_live = 7776000 -- 90 days for retention
    AND tombstone_gc = {'mode':'repair'};



-- Define a custom data type to hold the running sum and count
CREATE TYPE avg_state (sum int, count int);

-- Define the state function
CREATE OR REPLACE FUNCTION avg_sfunc(state avg_state, val text)
    RETURNS NULL ON NULL INPUT
    RETURNS avg_state
    LANGUAGE LUA AS '
  state.sum = state.sum + string.len(val)
  state.count = state.count + 1
  return state
';

-- Define the final function
CREATE OR REPLACE FUNCTION avg_finalfunc(state avg_state)
    RETURNS NULL ON NULL INPUT
    RETURNS double
    LANGUAGE LUA AS '
  return state.sum / state.count
';

-- Create the aggregate
CREATE OR REPLACE AGGREGATE average_message_length(text)
    SFUNC avg_sfunc
    STYPE avg_state
    FINALFUNC avg_finalfunc
    INITCOND { sum: 0, count: 0 };
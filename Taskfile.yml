version: '3'

vars:
  # --- Go and Project Paths ---
  SRC_DIR: './app/src'
  GOBIN_DIR: '{{.USERPROFILE}}\go\bin'

  # --- sqlc Tool Configuration ---
  SQLC_VERSION: '1.30.0'
  SQLC_OS: 'windows'
  SQLC_ARCH: 'amd64'
  SQLC_ZIP: 'sqlc_{{.SQLC_VERSION}}_{{.SQLC_OS}}_{{.SQLC_ARCH}}.zip'
  SQLC_URL: 'https://github.com/sqlc-dev/sqlc/releases/download/v{{.SQLC_VERSION}}/{{.SQLC_ZIP}}'
  SQLC_SCHEMA_FILE: './deployment/docker/postgresql/scripts/init.sql'
  SQLC_QUERIES_FILE: './deployment/docker/postgresql/scripts/queries.sql'
  SQLC_GEN_CODE_DIR: '{{.SRC_DIR}}/postgres/gen'

  # --- schemagen Tool Configuration ---
  SCHEMAGEN_CLUSTER: '127.0.0.1:19041'
  SCHEMAGEN_USER: 'chat_rw'
  SCHEMAGEN_PASSWORD: 'yT3-4d5dQiD6S-yHfThN'
  SCHEMAGEN_KEYSPACE: 'chat_db'
  SCHEMAGEN_OUTPUT: '{{.SRC_DIR}}/scylla/gen'
  SCHEMAGEN_PKGNAME: 'gen'

tasks:
  tools:sqlc:
    desc: 'Downloads and installs the sqlc binary if not already present.'
    vars:
      SQLC_EXE: '{{.GOBIN_DIR}}\sqlc.exe'
    status:
      - 'command -v sqlc'
    cmds:
      - echo "Installing sqlc v{{.SQLC_VERSION}}..."
      - mkdir -p {{.GOBIN_DIR}}
      - curl -L -o {{.SQLC_ZIP}} {{.SQLC_URL}}
      - unzip {{.SQLC_ZIP}} sqlc.exe
      - mv -f sqlc.exe "{{.SQLC_EXE}}"
      - rm -rf {{.SQLC_ZIP}}
      - 'echo "✅ sqlc installed successfully."'

  tools:reflex:
    desc: 'Install reflex CLI tool'
    status:
      - 'command -v reflex'
    cmds:
      - go install github.com/cespare/reflex@latest
    silent: true

  sqlc:generate:
    desc: 'Generate Go code from SQL schema and queries using sqlc.'
    deps:
      - tools:sqlc
    cmds:
      - sqlc -f sqlc.yaml generate
    sources:
      - '{{.SQLC_SCHEMA_FILE}}'
      - '{{.SQLC_QUERIES_FILE}}'
      - 'sqlc.yaml'
    generates:
      - '{{.SQLC_GEN_CODE_DIR}}/copyfrom.go'
      - '{{.SQLC_GEN_CODE_DIR}}/db.go'
      - '{{.SQLC_GEN_CODE_DIR}}/models.go'
      - '{{.SQLC_GEN_CODE_DIR}}/querier.go'
      - '{{.SQLC_GEN_CODE_DIR}}/queries.sql.go'
    method: checksum

  sqlc:clean:
    desc: 'Remove generated database Go files.'
    cmds:
      - rimraf {{.SQLC_GEN_CODE_DIR}}

  sqlc:watch:
    desc: 'Watch SQL files and regenerate Go code on changes.'
    deps:
      - tools:sqlc
      - tools:reflex
    cmds:
      - |
        reflex --start-service -r '\.sql$' --watch-dir ./deployment/docker/postgresql/scripts -- sh -c 'task sqlc:generate && echo "✅ sqlc generated successfully at $(date -u)"'

  tools:schemagen:
    desc: 'Downloads and installs the schemagen binary if not already present.'
    status:
      - 'command -v schemagen'
    cmds:
      - echo "⏳Installing schemagen..."
      - git clone git@github.com:scylladb/gocqlx.git
      - cd gocqlx/cmd/schemagen/
      - go install .
      - cd ../../..
      - rimraf gocqlx
      - 'echo "✅ schemagen installed successfully."'

  schemagen:gen:
    desc: 'Generate Go code from CQL schema'
    deps:
      - tools:schemagen
    cmds:
      - |
        schemagen \
          -cluster="{{.SCHEMAGEN_CLUSTER}}" \
          -user="{{.SCHEMAGEN_USER}}" \
          -password="{{.SCHEMAGEN_PASSWORD}}" \
          -keyspace="{{.SCHEMAGEN_KEYSPACE}}" \
          -output="{{.SCHEMAGEN_OUTPUT}}" \
          -pkgname="{{.SCHEMAGEN_PKGNAME}}"
    generates:
      - '{{.SCHEMAGEN_OUTPUT}}/gen.go'
    method: checksum

  schemagen:clean:
    desc: 'Remove generated ScyllaDB Go files.'
    cmds:
      - rimraf '{{.SCHEMAGEN_OUTPUT}}/gen.go'

  elastic:wipe:
    desc: 'Removes all docker containers and volumes associated with Elasticsearch, then restarts the stack'
    cmds:
      - |
        (cd deployment/docker && \
        TARGET_SERVICES=$(docker compose config --services | grep '^es-') && \
        if [ -z "$TARGET_SERVICES" ]; then
          echo "No target services found."
        else
          RUNNING_SERVICES=$(docker compose ps --services --filter status=running | grep -Ff - <<< "$TARGET_SERVICES") && \
          if [ -n "$RUNNING_SERVICES" ]; then
            echo "Stopping and removing running Elasticsearch services:"
            echo "$RUNNING_SERVICES"
            docker compose stop $RUNNING_SERVICES && docker compose rm -f $RUNNING_SERVICES
          else
            echo "No target Elasticsearch services are currently running. Skipping stop/remove."
          fi && \
          VOLUMES=$(docker volume ls -q --filter "name=chatapp-cluster_es-") && \
          if [ -n "$VOLUMES" ]; then
            echo "Removing volumes..."
            echo "$VOLUMES" | xargs -r docker volume rm -f
          fi && \
          echo "Recreating all target Elasticsearch services..."
          docker compose up -d --force-recreate $TARGET_SERVICES
        fi)

  postgres:wipe:
    desc: 'Removes all docker containers and volumes associated with PostgreSQL, then restarts the stack'
    cmds:
      - |
        (cd deployment/docker && \
        TARGET_SERVICES=$(docker compose config --services | grep -E '^pg-node-|^etcd$|^pgpool$|^pg-exporter$') && \
        if [ -z "$TARGET_SERVICES" ]; then
          echo "No target services found."
        else
          RUNNING_SERVICES=$(docker compose ps --services --filter status=running | grep -Ff - <<< "$TARGET_SERVICES") && \
          if [ -n "$RUNNING_SERVICES" ]; then
            echo "Stopping and removing running PostgreSQL services:"
            echo "$RUNNING_SERVICES"
            docker compose stop $RUNNING_SERVICES && docker compose rm -f $RUNNING_SERVICES
          else
            echo "No target PostgreSQL services are currently running. Skipping stop/remove."
          fi && \
          VOLUMES=$(docker volume ls -q --filter "name=pg-data-" --filter "name=etcd-data") && \
          if [ -n "$VOLUMES" ]; then
            echo "Removing volumes..."
            echo "$VOLUMES" | xargs -r docker volume rm -f
          fi && \
          echo "Recreating all target PostgreSQL services..."
          docker compose up -d --force-recreate $TARGET_SERVICES
        fi)

  scylla:wipe:
    desc: 'Removes all docker containers and volumes associated with ScyllaDB, then restarts the stack'
    cmds:
      - |
        (cd deployment/docker && \
        TARGET_SERVICES=$(docker compose config --services | grep -E '^scylla-node|^scylla-maintainer$') && \
        if [ -z "$TARGET_SERVICES" ]; then
          echo "No target services found."
        else
          RUNNING_SERVICES=$(docker compose ps --services --filter status=running | grep -Ff - <<< "$TARGET_SERVICES") && \
          if [ -n "$RUNNING_SERVICES" ]; then
            echo "Stopping and removing running services:"
            echo "$RUNNING_SERVICES"
            docker compose stop $RUNNING_SERVICES && docker compose rm -f $RUNNING_SERVICES
          else
            echo "No target services are currently running. Skipping stop/remove."
          fi && \
          VOLUMES=$(docker volume ls -q --filter "name=scylla-data-") && \
          if [ -n "$VOLUMES" ]; then
            echo "Removing volumes..."
            echo "$VOLUMES" | xargs -r docker volume rm -f
          fi && \
          echo "Recreating all target services..."
          docker compose up -d --force-recreate $TARGET_SERVICES
        fi)

  redis:wipe:
    desc: 'Removes all docker containers and volumes associated with Redis, then restarts the stack'
    cmds:
      - |
        (cd deployment/docker && \
        TARGET_SERVICES=$(docker compose config --services | grep '^redis-node-') && \
        if [ -z "$TARGET_SERVICES" ]; then
          echo "No target services found."
        else
          RUNNING_SERVICES=$(docker compose ps --services --filter status=running | grep -Ff - <<< "$TARGET_SERVICES") && \
          if [ -n "$RUNNING_SERVICES" ]; then
            echo "Stopping and removing running Redis services:"
            echo "$RUNNING_SERVICES"
            docker compose stop $RUNNING_SERVICES && docker compose rm -f $RUNNING_SERVICES
          else
            echo "No target Redis services are currently running. Skipping stop/remove."
          fi && \
          VOLUMES=$(docker volume ls -q --filter "name=redis-data-") && \
          if [ -n "$VOLUMES" ]; then
            echo "Removing volumes..."
            echo "$VOLUMES" | xargs -r docker volume rm -f
          fi && \
          echo "Recreating all target Redis services..."
          docker compose up -d --force-recreate $TARGET_SERVICES
        fi)

  volumes:wipe:
    desc: 'Removes all named volumes associated with this project'
    cmds:
      - docker volume ls | grep chatapp-cluster_ | awk '{print $2}' | xargs docker volume rm